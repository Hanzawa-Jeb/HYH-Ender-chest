[[c]]
```c
int main(){
	int a;
	scanf("%d", &a);
	return 0;
}
```
在这样一段示例代码之中，如果我们刚开始就输入字符是会报错的，因为scanf %d只会跳过第一个数字前面的空格与换行符等等，而不会跳过字符。
scanf会返回一个数字，这个数字所代表的意思是他读取到的参数个数，比如说在这里那么他读取到的参数个数应该为0。

如果是
```c
scanf("%s", &str);
```
- 那么这里将会==先跳过开头的所有空格字符==
- 然后进行读取，如果遇到空格或者换行符则结束读取并在字符串的最后添加一个`'\0'`
- ==读取结束后的`\n`==仍然会停留在缓冲区中，下一次读取仍然可以读取到。


# 关于puts与fputs
- puts会自动添加换行符， fputs不会

# 关于gets与fgets
关于 `fgets` 和 `gets` 是否会在字符串结尾**自动添加换行符**的问题，以下是详细的解释：

---

### 1. **`fgets`** ==如果设定字数上限为n，那么只能读进n-1个字符！！==
#### 行为：
- ==开头的空格将会被无差别读取==
- `fgets` 会从输入流中读取一行字符串，直到遇到换行符（`\n`）或达到指定的最大字符数。
- 如果读取到换行符（`\n`），`fgets` 会**将换行符保留**在字符串中。
- 无论是否读取到换行符，`fgets` 都会在字符串末尾**自动添加空字符（`\0`）**。
- 

#### 示例：
```c
char buffer[100];
fgets(buffer, sizeof(buffer), stdin);
```

如果输入是 `Hello\n`，那么 `buffer` 的内容将是：

```
Hello\n\0
```

---

### 2. **`gets`**
#### 行为：
- `gets` 会从标准输入中读取一行字符串，直到遇到换行符（`\n`）。
- 如果读取到换行符（`\n`），`gets` 会==**丢弃换行符**==，不会将其保留在字符串中。
- `gets` 会在字符串末尾**自动添加空字符（`\0`）**。

#### 示例：
```c
char buffer[100];
gets(buffer); // 不推荐使用
```

如果输入是 `Hello\n`，那么 `buffer` 的内容将是：

```
Hello\0
```

---

### 对比总结

| 函数     | 是否保留换行符 | 是否自动添加 `\0` |
|----------|----------------|-------------------|
| `fgets`  | 是             | 是                |
| `gets`   | 否             | 是                |

---

### 注意事项
1. **`fgets` 的换行符处理**：
   - 如果你不希望字符串中包含换行符，可以在使用 `fgets` 后手动移除换行符。例如：
     ```c
     char buffer[100];
     fgets(buffer, sizeof(buffer), stdin);
     // 移除换行符
     size_t len = strlen(buffer);
     if (len > 0 && buffer[len - 1] == '\n') {
         buffer[len - 1] = '\0';
     }
     ```

2. **`gets` 的安全性问题**：
   - `gets` 不会检查缓冲区的大小，如果输入的数据长度超过缓冲区的大小，会导致**缓冲区溢出**，这是一个严重的安全隐患。因此，`gets` 在C11标准中已被移除，建议始终使用 `fgets` 替代。

---

### 总结
- `fgets` 会保留换行符，并在字符串末尾添加 `\0`。
- `gets` 会丢弃换行符，并在字符串末尾添加 `\0`。
- 出于安全性考虑，建议始终使用 `fgets` 而不是 `gets`。